{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Tikz-Python!","text":"<p>Tikz-Python is intended to be an easy-to-use, no-nonsense python package meant to serve as an interface to TikZ code. With Tikz-Python, you can have your beautiful vector graphics and eat it too! (erh, maybe).  </p> <p>Install it below as follows: <pre><code>pip install tikz-python\n</code></pre></p> <p>Want to see some nice examples of what this package can do? See here.</p>"},{"location":"#usage","title":"Usage","text":"<p>Suppose we want to create a sphere. We can achieve this as follows. <pre><code>from tikzpy import TikzPicture  \ntikz = TikzPicture() # Initialize empty canvas\ntikz.circle((0, 0), 3, options=\"thin, fill=orange!15\")\n# Draw two arcs to give 3d-illusion\ntikz.arc((3, 0), 0, 180, x_radius=3, y_radius=1.5, options=\"dashed\")\ntikz.arc((-3, 0), 180, 360, x_radius=3, y_radius=1.5)\ntikz.show()  # Displays a pdf of the drawing to the user\n</code></pre> which produces  </p>"},{"location":"#why-tikz-python","title":"Why Tikz-Python","text":"<p>With Tikz-Python, you generate TikZ code by writing python code. And Python is much nicer than TeX. </p> <ul> <li> <p>Instead of spending a lot of time tediously writing messy, unreadable TikZ code to generate your desired figure,  you can use TikZ-Python to quickly create your figure as a Python script. Your Python code will definitely be much  more modular and extensible than the raw TikZ code you'd end up writing. </p> </li> <li> <p>At any time, you can compile and look at your figure in a sandbox environment by calling <code>TikzPicture.show()</code></p> </li> <li> <p>With a sandbox environment for compilation, compiling will be faster versus you editing and re-compiling your tikz code directly in whatever 100-page document you're working in.</p> </li> <li> <p>Once you're happy with your drawing, you can copy the generated TikZ code and paste it into your LaTeX document. Or, you can  save your code to a file by calling <code>TikzPicture.write(file_destination)</code>.</p> </li> </ul> <p>Additionally, Tikz-Python encodes lines, circles, rectangles, etc. as data structures. These data structures have useful properties and methods that can be used to create other drawings.</p> <p>For example, suppose I want to create a line and two labels at the ends. The code below achieves this <pre><code>from tikzpy import TikzPicture\ntikz = TikzPicture()\nline = tikz.line((0, 0), (1, 1), options=\"thick, blue, o-o\")\nstart_node = tikz.node(line.start, options=\"below\", text=\"Start!\")\nend_node = tikz.node(line.end, options=\"above\", text=\"End!\")\n</code></pre> which produces   Saving the line as a variable <code>line</code> allows us to pass in <code>line.start</code> and <code>line.end</code> into the node positions, so we don't have to type out the exact coordinates.  This is great, because it makes our code more modular and therefore easier to change. With TikZ alone, you'd need to type out exact coordinates, and update every single one each time you make a minor adjustment to your code.</p> <p>If we were working in an interactive python shell with the code above, we would be able to see that these functions return classes with useful attributes: <pre><code>&gt;&gt;&gt; line.start\n(0,0)\n&gt;&gt;&gt; line.end\n(1,1)\n&gt;&gt;&gt; start_node.text\n\"Start!\"\n</code></pre> Additionally, you can <code>print</code> your tikz object to see the code generated <pre><code>At any time, you can look at the current TikZ code you've created \n```python\n&gt;&gt;&gt; print(tikz)\n\\begin{tikzpicture}\n    \\draw[thick, blue, o-o] (0, 0) to (1, 1);\n    \\node[below] at (0, 0) { Start! };\n    \\node[above] at (1, 1) { End! };\n\\end{tikzpicture}\n</code></pre> which you can then use to export to your project.</p>"},{"location":"#background","title":"Background","text":"<p>TikZ is itself a wrapper of the TeX-based graphics package PGF (see here), and it is commonly used in LaTeX documents to produce beautiful graphics. However, the power of TikZ comes with a tradeoff: it is extremely tedious to use, learn, understand, and iterate on. </p> <p>The main problem is Tikz is that, even though Tikz is so powerful, it is often the case that  nonexperts who use TikZ end up producing subpar images.  The reason for this is because of the fact that in order to create beautiful images with TikZ, you also need to deeply understand  LaTeX, TeX, PGF, and the history, bugs, cryptic error messages, and ridiculous quirks (and there are many quirks) of these languages.  This takes years of practice and for the average person this is not realistic or desirable.</p> <p>This can be seen in research papers; even in high quality research papers, the graphics are usually not that great and it totally makes sense why.  It's probably because the authors are too busy being an expert in their own field of work to sit down and read a 1300 page manual on TikZ.</p>"},{"location":"#about","title":"About","text":"<p>I started this project after realizing </p> <ul> <li> <p>most TikZ code is repetitive.</p> </li> <li> <p>TikZ was designed smart; it has an inherent object oriented pattern in its usage which we can exploit and automate.</p> </li> <li> <p>I really hate writing TeX and TikZ code.</p> </li> </ul> <p>I wrote the first version of this as a math undergraduate while writing a large set of notes. As a heavy user of LaTeX, TikZ, PGF, I knew how to design the project to enable efficient development of TikZ code. Then I became a professional software engineer, and I refactored the code to a modern python package while maintaining the original desired goals of the package. </p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#line-and-two-nodes","title":"Line and two nodes","text":"<p>Suppose I want to create a line and two labels at the ends. The code below achieves this <pre><code>from tikzpy import TikzPicture\ntikz = TikzPicture()\nline = tikz.line((0, 0), (1, 1), options=\"thick, blue, o-o\")\nstart_node = tikz.node(line.start, options=\"below\", text=\"Start!\")\nend_node = tikz.node(line.end, options=\"above\", text=\"End!\")\n</code></pre> and produces</p> <p> </p> <p>Saving the line as a variable <code>line</code> allows us to pass in <code>line.start</code> and <code>line.end</code> into the node positions, so we don't have to type out the exact coordinates.  This is because lines, nodes, etc. are class instances with useful attributes:  <pre><code>&gt;&gt;&gt; line.start\n(0,0)\n&gt;&gt;&gt; line.end\n(1,1)\n&gt;&gt;&gt; start_node.text\n\"Start!\"\n</code></pre></p>"},{"location":"examples/#circles","title":"Circles","text":"<p>In this example, we use a for loop to draw a pattern of circles. </p> <p>This example  demonstates how Pythons <code>for</code> loop is a lot less messier than the <code>\\foreach</code> loop provided in Tikz via TeX. (It is also more powerful; for example, Tikz with TeX alone guesses your step size, and hence it cannot effectively loop over two different sequences at the same time).</p> <p><pre><code>import numpy as np\nfrom tikzpy import TikzPicture\ntikz = TikzPicture(center=True)\nfor i in np.linspace(0, 1, 30): # Grab 30 equidistant points in [0, 1]\npoint = (np.sin(2 * np.pi * i), np.cos(2 * np.pi * i))\n# Create four circles of different radii with center located at point\ntikz.circle(point, 2, \"ProcessBlue\")\ntikz.circle(point, 2.2, \"ForestGreen\")\ntikz.circle(point, 2.4, \"red\")  # xcolor Red is very ugly\ntikz.circle(point, 2.6, \"Purple\")\n</code></pre> The above code then produces</p> <p></p>"},{"location":"examples/#roots-of-unity","title":"Roots of Unity","text":"<p>In this example, we draw the 13 roots of unity. </p> <p>If we wanted to normally do this in TeX, we'd probably have to spend 30 minutes reading some manual about how TeX handles basic math. With Python, we can just use the <code>math</code> library and make intuitive computations to quickly build a function that displays the nth roots of unity. <pre><code>from math import pi, sin, cos\nfrom tikzpy import TikzPicture\ntikz = TikzPicture()\nn = 13 # Let's see the 13 roots of unity\nscale = 5\nfor i in range(n):\ntheta = (2 * pi * i) / n\nx, y = scale * cos(theta), scale * sin(theta)\ncontent = f\"$e^{{ (2 \\cdot \\pi \\cdot {i})/ {n} }}$\"\n# Draw line to nth root of unity\ntikz.line((0, 0), (x, y), options=\"-o\")\nif 0 &lt;= theta &lt;= pi:\nnode_option = \"above\"\nelse:\nnode_option = \"below\"\n# Label the nth root of unity\ntikz.node((x, y), options=node_option, text=content)\n</code></pre> Which generates: </p> <p></p> <p>We will see in the examples that follow how imported Python libraries can alllow us to quickly (and efficiently, this is really important) make more sophisticated Tikz pictures. </p>"},{"location":"examples/#general-ven-diagrams","title":"General Ven Diagrams","text":"<p>In the source here, we use the python library <code>itertools.combinations</code> to create a function which takes in an arbitrary number of 2D Tikz figures and colors each and every single intersection. </p> <p>For example, suppose we arrange nine circles in a 3 x 3 grid. Plugging these nine circles in, we generate the image below.</p> <p></p> <p>As another example, we can create three different overlapping topological blobs and then plug them into the function to obtain</p> <p></p> <p>(Both examples are initialized in the source for testing.) As one might guess, this function is useful for creating topological figures, as manually writing all of the <code>\\scope</code> and <code>\\clip</code> commands to create such images is pretty tedious.</p>"},{"location":"examples/#barycentric-subdivision","title":"Barycentric subdivision","text":"<p>In the source here, we create a function that allows us to generate the the n-th barycentric subdivision of a triangle. </p> <p></p>"},{"location":"examples/#cantor-function","title":"Cantor function","text":"<p>In the source here, we plot the Cantor function by performing recursion. It is clear from this TeX Stackexchange question that TeX alone cannot do this, as most answers rely on external programs to generate the data. </p> <p></p>"},{"location":"examples/#symbolic-intergation","title":"Symbolic Intergation","text":"<p>In the source here, we use <code>numpy</code> and <code>sympy</code> to very simply perform symbolic integration. The result is a function which plots and labels the n-order integrals of any function. For example, the output of <code>x**2</code> (the polynomial x^2) generates the image below. </p> <p></p>"},{"location":"examples/#cone-over-a-projective-variety","title":"Cone over a Projective Variety","text":"<p>In the source here, we use <code>numpy</code> to create an image which illustrates the concept of an affine cone over a projective variety. In the case of a curve Y in P^2, the cone C(Y) is a surface in A^3. </p> <p>The image that this drawing was modeled after appears in Exercise 2.10 of Hartshorne's Algebraic Geometry.</p> <p></p>"},{"location":"examples/#lorenz-system","title":"Lorenz System","text":"<p>In the source here, we use <code>numpy</code> and <code>scipy</code> to solve ODEs and plot the Lorenz system. This is made possible since <code>tikz_py</code> also supports 3D. </p> <p></p>"},{"location":"examples/#tikz-styles","title":"Tikz Styles","text":"<p><code>tikzpy</code> supports the creation of any <code>\\tikzset</code>, a feature of Tikz that saves users a great deal of time. You can save your tikz styles in a .py file instead of copying and pasting all the time. </p> <p>Even if you don't want to make such settings, there are useful <code>\\tikzset</code> styles that are preloaded in <code>tikzpy</code>. One particular is the very popular tikzset authored by Paul Gaborit in this TeX stackexchange question. Using such settings, we create these pictures, which illustrate Cauchy's Residue Theorem. The source here produces </p> <p></p> <p>while the source here produces </p> <p></p>"},{"location":"examples/#linear-transformations","title":"Linear Transformations","text":"<p>Recall a 3x2 matrix is a linear transformation from R^2 to R^3. Using such an interpretation, we create a function in the source here which plots the image of a 3x2 matrix. The input is in the form of a <code>numpy.array</code>. </p> <p>For example, plugging the array <code>np.array([[0, 1], [1, 1], [0, 1]])</code> into the source produces </p> <p></p> <p>while plugging the array <code>np.array([[2, 0], [1, 1], [1, 1]])</code> into the source produces </p> <p></p>"},{"location":"examples/#projecting-r1-onto-s1","title":"Projecting R^1 onto S^1","text":"<p>In the source here, we use <code>numpy</code> to illustrate the projection of R^1 onto S^1. Creating this figure in Tex alone is nontrivial, as one must create white space at self intersections to illustrate crossovers. Existing tikz solutions cannot take care of this, but the flexible logical operators of Python allow one to achieve it. </p> <p></p>"},{"location":"examples/#polar-coordinates","title":"Polar Coordinates","text":"<p>In the source here, we illustrate the concept of polar coordiantes by demonstrating how a sine curve is mapped into polar coordinates. This example should be compared to the more complex answers in this TeX Stackexchange question which seeks a similar result. </p> <p></p>"},{"location":"examples/#blowup-at-a-point","title":"Blowup at a point","text":"<p>In the source here, we illustrate the blowup of a point, a construction in algebraic geometry. This picture was created in 5 minutes and in half the lines of code compared to this popular TeX stackexchange answer, which uses quite convoluted, C-like Asymptote code.</p> <p></p>"},{"location":"installation/","title":"Installation","text":"<p>To install Tikz-Python, run <pre><code>pip install tikz-python\n</code></pre> In order to compile your drawings, you need an installation of <code>LaTeX</code>, with PDF and TikZ libraries and latexmk. Unless you decided to customize your LaTeX installation, all of these should already be on your system. </p> <p>If you don't have these on your system, you can of course still use Tikz-Python to generate Tikz code, which you can then take to another system with LaTeX installed to compile on.</p>"},{"location":"tikz_picture/","title":"<code>TikzPicture</code>","text":"<p>The <code>TikzPicture</code> class acts a canvas in which users can append drawings to. In the background, the <code>TikzPicture</code> manages the creation of the tikz code. The signature of the class is given below.</p> <pre><code>TikzPicture(center=center, options=options)\n</code></pre> Parameter Description Default <code>center</code> (bool) True if you would like your tikzpicture to be centered, false otherwise. <code>False</code> <code>options</code> (str) A string containing valid Tikz options. <code>\"\"</code>"},{"location":"tikz_picture/#methods","title":"Methods","text":""},{"location":"tikz_picture/#tikzpictureline","title":"<code>TikzPicture.line()</code>","text":"<p>Draws a line  <pre><code>line(\nstart: Union[Tuple[float, float], Point],\nend: Union[Tuple[float, float], Point],\noptions: str = \"\",\nto_options: str = \"\",\ncontrol_pts: list = [],\naction: str = \"draw\",\n) -&gt; Line:\n</code></pre></p>"},{"location":"tikz_picture/#tikzpictureplot_coordinates","title":"<code>TikzPicture.plot_coordinates</code>","text":"<pre><code>plot_coordinates(\n    points: Union[List[tuple], List[Point]],\n    options: str = \"\",\n    plot_options: str = \"\",\n    action: str = \"draw\",\n) -&gt; PlotCoordinates:\n</code></pre>"},{"location":"tikz_picture/#tikzpicturecircle","title":"<code>TikzPicture.circle</code>","text":"<pre><code>def circle(\nself,\ncenter: Union[Tuple[float, float], Point],\nradius: float,\noptions: str = \"\",\naction: str = \"draw\",\n) -&gt; Circle:\n</code></pre>"},{"location":"tikz_picture/#tikzpicturenode","title":"<code>TikzPicture.node</code>","text":"<pre><code>def node(\nself,\nposition: Union[Tuple[float, float], Point],\noptions: str = \"\",\ntext: str = \"\",\n) -&gt; Node:\n</code></pre>"},{"location":"tikz_picture/#tikzpicturerectangle","title":"<code>TikzPicture.rectangle</code>","text":"<pre><code>def rectangle(\nself,\nleft_corner: Union[Tuple[float, float], Point] = Point(0, 0),\nright_corner: Union[Tuple[float, float], Point] = Point(0, 0),\noptions: str = \"\",\naction: str = \"draw\",\n) -&gt; Rectangle:\n</code></pre>"},{"location":"tikz_picture/#tikzpictureellipse","title":"<code>TikzPicture.ellipse</code>","text":"<pre><code>def ellipse(\nself,\ncenter: Union[Tuple[float, float], Point],\nx_axis: float,\ny_axis: float,\noptions: str = \"\",\naction: str = \"draw\",\n) -&gt; Ellipse:\n</code></pre>"},{"location":"tikz_picture/#tikzpicturearc","title":"<code>TikzPicture.arc</code>","text":"<pre><code>def arc(\nself,\nposition: Union[Tuple[float, float], Point],\nstart_angle: float,\nend_angle: float,\nradius: float = None,\nx_radius: float = None,\ny_radius: float = None,\noptions: str = \"\",\nradians: bool = False,\ndraw_from_start: bool = True,\naction: str = \"draw\",\n) -&gt; Arc:\n</code></pre>"},{"location":"tikz_picture/#tikzpictureshow","title":"<code>TikzPicture.show()</code>","text":"<p>Compiles the TikZ code currently created and displays it to the user. This should either open the PDF viewer on the user's computer with the graphic, or open the PDF in the user's browser. </p>"},{"location":"tikz_picture/#tikzpicturewritefile","title":"<code>TikzPicture.write(file)</code>","text":"<p>Writes the currently recorded Tikz code into the the desired <code>file</code>. If <code>file</code> is empty. The default value of this parameter is <code>tikz_code.tex</code>.</p>"},{"location":"tikz_picture/#tikzpicturecompile","title":"<code>TikzPicture.compile()</code>","text":"<p>Compiles the tikz code and moves the compiled PDF to the user's current working directory.</p>"},{"location":"tikz_picture/#tikzpicturewrite_tex_filefile","title":"<code>TikzPicture.write_tex_file(file)</code>","text":"<p>Writes the entire tex code, in addition to the Tikz code, into the the desired <code>file</code>. If <code>file</code> is empty. The default value of this parameter is <code>tikz_code.tex</code>.</p>"},{"location":"Drawing%20Objects/arc/","title":"<code>Arc</code>","text":"<p>The arc class helps create arcs in Tikz. It is analagous to the TikZ code  <pre><code>\\draw &lt;center&gt; arc (&lt;start_angle&gt;:&lt;end_angle&gt;:&lt;radius&gt;);\n</code></pre> The signature of this class is below. <pre><code>from tikzpy import Arc\narc = Arc(center, start_angle, end_angle, radius, options, radians, action)\n</code></pre></p> Parameter Description Default <code>position</code> (tuple) Pair of points representing either the center of the arc or the point at which it should begin drawing (see <code>draw_from_start</code> <code>start_angle</code> (float) The angle (relative to the horizontal) of the start of the arc <code>end_angle</code> (float) The angle (relative to the horizontal) of the end of the arc <code>radius</code> (float) The radius (in cm) of the arc. If specified, <code>x_radius</code> and <code>y_radius</code> cannot be specified. <code>x_radius</code> (float) The x radius (in cm) of the arc. In this case, <code>y_radius</code> must also be specified. <code>y_radius</code> (float) The y radius (in cm) of the arc. In this case, the <code>x_radius</code> must also be specified. <code>options</code> (str) A string of containing valid Tikz arc options <code>\"\"</code> <code>radians</code> (bool) <code>True</code> if angles are in radians, <code>False</code> otherwise <code>False</code> <code>draw_from_start</code> (bool) <code>True</code> if <code>position</code> represents the point at which the arc should begin drawing. <code>False</code> if <code>position</code> represents the center of the desired arc. <code>True</code> <code>action</code> (str) An action to perform with the arc (e.g., <code>\\draw</code>, <code>\\fill</code>, <code>\\filldraw</code>, <code>\\path</code>) <code>\"\\draw\"</code>"},{"location":"Drawing%20Objects/arc/#example","title":"Example","text":"<p>Here we draw and fill a sequence of arcs. We also demonstrate <code>draw_from_start</code> set to <code>True</code> and <code>False</code>. In the code below, it is by default set to <code>True</code>. <pre><code>from tikzpy import TikzPicture\nfrom tikzpy.utils import rainbow_colors\ntikz = TikzPicture()\nfor i in range(1, 10):\nt = 4 / i\narc = tikz.arc((0, 0), 0, 180, radius=t, options=f\"fill={rainbow_colors(i)}\")\n</code></pre> This generates the image</p> <p></p> <p>If instead we would like these arcs sharing the same center, we can use the same code, but pass in <code>draw_from_start=False</code> to achieve </p> <p></p> <p>Without this option, if we were forced to specify the point at which each arc should begin drawing, we would have to calculate the x-shift for every arc and apply such a shift to keep the centers aligned. That sounds inefficient and like a waste of time to achieve something so simple, right?</p>"},{"location":"Drawing%20Objects/arc/#methods","title":"Methods","text":"<p><code>Arc</code> has access to methods <code>.shift()</code>, <code>.scale()</code>, <code>.rotate()</code>, which behave as one would expect and takes in parameters as described before.</p>"},{"location":"Drawing%20Objects/arc/#a-few-comments","title":"A few comments...","text":"<p>This class not only provides a wrapper to draw arcs, but it also fixes a few things that Tikz's <code>\\draw arc</code> command simply gets wrong and confuses users with.</p> <ol> <li> <p>With Tikz in TeX, to draw a circular arc one must specify <code>start_angle</code> and <code>end_angle</code>. These make sense: they are the start and end angles of the arc relative to the horizontal. To draw an elliptic arc, one must again specify <code>start_angle</code> and <code>end_angle</code>, but these actually do not represent the starting and end angles of the elliptic arc. They are the parameters <code>t</code> which parameterize the ellipse <code>(a*cos(t), b*sin(t))</code>. This makes drawing elliptic arcs inconvenient.</p> </li> <li> <p>With Tikz in TeX, the position of the arc is specified by where the arc should start drawing. However, it is sometimes easier to specify the center of the arc.</p> </li> </ol> <p>With Tikz-Python, <code>start_angle</code> and <code>end_angle</code> will always coincide with the starting and end angles, so the user will not get weird unexpected behavior. Additionally, the user can specify the arc position via its center by setting <code>draw_from_start=False</code>, but they can also fall back on the default behavior.</p>"},{"location":"Drawing%20Objects/circle/","title":"<code>Circle</code>","text":"<p>The <code>Circle</code> class helps create circles in Tikz. It is analagous to the Tikz code  <pre><code>\\draw &lt;center&gt; circle &lt;radius&gt;\n</code></pre> The signature of the class is below. <pre><code>from tikzpy import Circle\ncircle = Circle(center, radius, options, action)\n</code></pre></p> Parameter Description Default <code>center</code> (tuple) A tuple (x, y) of floats representing the coordinates of the center of the circle. <code>radius</code> (float) Length (in cm) of the radius. (By the way, all lengths are taken in cm). <code>options</code> (str) String containing valid Tikz drawing options (e.g, \"Blue\") <code>\"\"</code> <code>action</code> (str) An action to perform with the circle (e.g., <code>\\draw</code>, <code>\\fill</code>, <code>\\filldraw</code>, <code>\\path</code>) <code>\"\\draw\"</code>"},{"location":"Drawing%20Objects/circle/#examples","title":"Examples","text":"<p>Here we create several circles, making use of the <code>action</code> parameter.  <pre><code>import tikzpy\ntikz = tikzpy.TikzPicture()\ntikz.circle((0, 0), 1.25) #action=\"draw\" by default\ntikz.line((0, 0), (0, 1.25), options=\"dashed\")\ntikz.circle((3, 0), 1, options=\"thick, fill=red!60\", action=\"filldraw\")\ntikz.circle((6, 0), 1.25, options=\"Green!50\", action=\"fill\")\n</code></pre></p> <p></p> <p>We can also use circles to create the Hawaiian Earing.</p> <p><pre><code>import tikzpy\ntikz = tikzpy.TikzPicture()\nradius = 5\nfor i in range(1, 60):\nn = radius / i\ntikz.circle((n, 0), n)\n</code></pre> </p>"},{"location":"Drawing%20Objects/circle/#attributes","title":"Attributes","text":"<p>The <code>Circle</code> class has attributes that are commonly used when making a TikZ graphic that has circles.</p>"},{"location":"Drawing%20Objects/circle/#circlenorth","title":"<code>Circle.north</code>","text":"<p>Returns a <code>Point</code> object representing the north point on the circle.</p>"},{"location":"Drawing%20Objects/circle/#circleeast","title":"<code>Circle.east</code>","text":"<p>Returns a <code>Point</code> object representing the east point on the circle.</p>"},{"location":"Drawing%20Objects/circle/#circlesouth","title":"<code>Circle.south</code>","text":"<p>Returns a <code>Point</code> object representing the south point on the circle.</p>"},{"location":"Drawing%20Objects/circle/#circlewest","title":"<code>Circle.west</code>","text":"<p>Returns a <code>Point</code> object representing the west point on the circle.</p>"},{"location":"Drawing%20Objects/circle/#methods","title":"Methods","text":"<p>The circle class has the following methods.</p>"},{"location":"Drawing%20Objects/circle/#circlepoint_at_argangle-float-radiansfalse-point","title":"<code>Circle.point_at_arg(angle: float, radians=False) -&gt; Point</code>","text":"<p>Returns a <code>Point</code> object representing the coordinates of the point on the circle at angle <code>angle</code> relative to the horizontal. One can use the optional argument <code>radians</code> to use either radians or degrees (the default).</p> <p><code>Circle</code> has access to methods <code>.shift()</code>, <code>.scale()</code>, <code>.rotate()</code>, which behave as one would expect and takes in parameters as described before.</p>"},{"location":"Drawing%20Objects/clip/","title":"<code>Clip</code>","text":"<p>A class to clip a single drawing object <code>draw_obj</code>. This is meant to be used in  conjunction with the <code>Scope</code> class. It is analagous to the tikz code</p> <p><pre><code>\\clip ... # some drawing object\n</code></pre> Below is the signature of the <code>Clip</code> class.</p> <pre><code>from tikzpy import Clip\nclip = Clip(draw_obj, draw).\n</code></pre> Parameter Description Default <code>draw_ob</code> (DrawingObject) A tikz-python DrawingObject (e.g. <code>Line</code>, <code>Circle</code>, etc.) <code>\"\"</code> <code>draw</code> (bool) If <code>True</code>, the clipped object is drawn to the graphic, otherwise it is hidden. <code>False</code> <p>The class <code>Clip</code> has access to methods <code>.shift()</code>, <code>.scale()</code>, <code>.rotate()</code>, although this is more for consistency  (e.g., in case a <code>Scope</code> environment changes) and less for direct use of the user. </p>"},{"location":"Drawing%20Objects/ellipse/","title":"<code>Ellipse</code>","text":"<p>The ellipse class handles ellipses in Tikz. It it analagous to the Tikz command  <pre><code>\\draw[options] &lt;center&gt; ellipse (&lt;x_radius&gt; and &lt;y_radius&gt;);\n</code></pre> The signature of the class is given below. <pre><code>from tikzpy import Ellipse\nellipse = Ellipse(center, x_axis, y_axis, options, action)\n</code></pre></p> Parameter Description Default <code>center</code> (tuple) Pair of floats representing the center of the ellipse <code>x_axis</code> (float) The length (in cm) of the horizontal axis of the ellipse <code>y_axis</code> (float) The length (in cm) of the vertical axis of the ellipse <code>action</code> (str) An action to perform with the ellipse (e.g., <code>\\draw</code>, <code>\\fill</code>, <code>\\filldraw</code>, <code>\\path</code>) <code>\"\\draw\"</code>"},{"location":"Drawing%20Objects/ellipse/#example","title":"Example","text":"<p>Here we draw and ellipse and define the major and minors axes. <pre><code>import tikzpy\ntikz = tikzpy.TikzPicture()\n# x,y axes\ntikz.line((-5, 0), (5, 0), options=\"Gray!40, -&gt;\")\ntikz.line((0, -5), (0, 5), options=\"Gray!40, -&gt;\")\n# Ellipse\nellipse = tikz.ellipse(\n(0, 0), 4, 3, options=\"fill=ProcessBlue!70, opacity=0.4\", action=\"filldraw\"\n)\n# Labels\nh_line = tikz.line((0, 0), (ellipse.x_axis, 0), options=\"thick, dashed, -&gt;\")\nv_line = tikz.line((0, 0), (0, ellipse.y_axis), options=\"thick, dashed, -&gt;\")\ntikz.node(h_line.midpoint, options=\"below\", text=\"Major\")\ntikz.node(v_line.midpoint, options=\"left\", text=\"Minor\")\n</code></pre></p> <p></p>"},{"location":"Drawing%20Objects/ellipse/#methods","title":"Methods","text":"<p><code>Ellipse</code> has access to methods <code>.shift()</code>, <code>.scale()</code>, <code>.rotate()</code>, which behave as one would expect and takes in parameters as described before.</p>"},{"location":"Drawing%20Objects/line/","title":"<code>Line</code>","text":"<p>The <code>Line</code> class helps handle the creation of lines in tikz code. It is analagous to the TikZ code  <pre><code>\\draw[&lt;options&gt;] &lt;start&gt; to [&lt;to_options&gt;] &lt;end&gt;;\n</code></pre> Lines in TikZ have even more features, like adding control points, and these features are accessible through the Line class.</p> <p>The signature of the <code>Line</code> class is as follows.  <pre><code>Line(start, end, options, to_options, control_pts, action) # A line is created and drawn\n</code></pre></p> Parameter Description Default <code>start</code> (tuple) Pair of floats representing the start of the line <code>end</code> (tuple) Pair of floats representing the end of the line <code>options</code> (str) String containing valid Tikz drawing options, e.g. \"Blue\" <code>\"\"</code> <code>to_options</code> (str) String containing Tikz specifications for connecting the start to the end (e.g. <code>\"to [bend right = 45]\"</code>) \"--\" <code>control_pts</code> (list) List of control points for the line <code>[]</code> <code>action</code> (str) An action to perform with plot (e.g., <code>\\draw</code>, <code>\\fill</code>, <code>\\filldraw</code>, <code>\\path</code>) <code>\"\\draw\"</code> <p>Here's an example of us using the <code>Line</code> class. <pre><code>import tikzpy\ntikz = tikzpy.TikzPicture()\ntikz.line((0, 0), (4, 0), options=\"-&gt;\", control_pts=[(1, 1), (3, -1)]\n</code></pre> which generates  </p>"},{"location":"Drawing%20Objects/line/#methods","title":"Methods","text":"<p>The <code>Line</code> class has the following methods.</p>"},{"location":"Drawing%20Objects/line/#linepos_at_tt-float","title":"<code>Line.pos_at_t(t: float)</code>","text":"<p>Returns a <code>Point</code> object representing the parametrized point on the line at time <code>t</code>, where <code>0 &lt;= t &lt;= 1</code>. Thus, when <code>t = 0</code> the start position of the line is returned, and when <code>t = 1</code> the end position of the line is returned.</p>"},{"location":"Drawing%20Objects/node/","title":"<code>Node</code>","text":"<p>The <code>Node</code> class is an object that is used  <pre><code>from tikzpy import Node\nnode = Node(position, options, text)\n</code></pre></p> Parameter Description Default <code>position</code> (tuple) A tuple (x, y) of floats representing the position of the node <code>options</code> (str) String containing valid Tikz node options (e.g., \"Above\") <code>\"\"</code> <code>text</code> (str) A string containing content, such as text or LaTeX code, to be displayed with the node <code>\"\"</code>"},{"location":"Drawing%20Objects/node/#examples","title":"Examples","text":"<p>Here we use some nodes to label a figure explaining the logarithm branch cut <pre><code>import tikzpy\ntikz = tikzpy.TikzPicture()\n# x,y axes\ntikz.line((-4, 0), (4, 0), options=\"Gray!40, -&gt;\")\ntikz.line((0, -4), (0, 4), options=\"Gray!40, -&gt;\")\n# Cut\ntikz.line((-4, 0), (0, 0), options=\"thick\")\n# Line out\ntikz.line((0, 0), (1.414, 1.414), options=\"-o\")\ntikz.arc((1, 0), 0, 45, radius=1, options=\"dashed\")\n# Labels\ntikz.node((3.6, -0.2), text=\"$x$\")\ntikz.node((-0.24, 3.53), text=\"$iy$\")\ntikz.node((1.3, 0.4), text=\"$\\\\theta$\")\ntikz.node((2.1, 1.7), text=\"$z = re^{i\\\\theta}$\")\ntikz.node((-2, 0.3), text=\"Cut\")\n</code></pre> which produces </p> <p>Here's another example of usings nodes to illustrate the concept of a multivariable function. <pre><code>import tikzpy\nrow_1 = tikzpy.TikzPicture()\n# Lines and rectangles\nrow_1.line((0, 0), (2, 0), options=\"-&gt;\")\nrow_1.rectangle((2, -0.5), (4, 0.5))\nrow_1.line((4, 0), (6, 0), options=\"-&gt;\")\n# Labels\nrow_1.node((-1.2, 0), text=\"$(x_1, \\dots, x_n)$\")\nrow_1.node((1, 0.3), text=\"input\")\nrow_1.node((3, 0), text=\"$f$\")\nrow_1.node((5, 0.3), text=\"output\")\nrow_1.node((7.3, 0), text=\"$f(x_1, \\dots, x_n)$\")\n</code></pre></p> <p></p>"},{"location":"Drawing%20Objects/node/#methods","title":"Methods","text":"<p><code>Node</code> has access to methods <code>.shift()</code>, <code>.scale()</code>, <code>.rotate()</code>, which behave as one would expect and takes in parameters as described before.</p>"},{"location":"Drawing%20Objects/plot_coordinates/","title":"<code>PlotCoordinates</code>","text":"<p>The <code>PlotCoordinates</code> class is used to represent the plot_coordinates functionality in TikZ. It is analagous to the TikZ command  <pre><code>\\draw plot[&lt;options&gt;] coordinates{ &lt;points&gt; };\n</code></pre> The signature of the class is given below. <pre><code>from tikzpy import PlotCoordinates\nplot = PlotCoordinates(points, options, plot_options, action)\n</code></pre></p> Parameter Description Default <code>points</code> (list) A list of tuples (x, y) representing coordinates that one wishes to create a plot for. <code>options</code> (str) A string of valid Tikz drawing options. <code>\"\"</code> <code>plot_options</code> (str) A string of valid Tikz plotting options <code>\"\"</code> <code>action</code> (str) An action to perform with the line (e.g., <code>\\draw</code>, <code>\\fill</code>, <code>\\filldraw</code>, <code>\\path</code>) <code>\"\\draw\"</code>"},{"location":"Drawing%20Objects/plot_coordinates/#examples","title":"Examples","text":"<p>Introducing examples of <code>PlotCoordinates</code> gives us an opportunity to illustrate the optional parameter <code>action</code>. By default, <code>action</code> is <code>\"draw\"</code> (analogous to <code>\\draw</code> in Tikz) so the code below <pre><code>import tikzpy\ntikz = tikzpy.TikzPicture()\npoints = [(2, 2), (4, 0), (1, -3), (-2, -1), (-1, 3)]\nplot = tikz.plot_coordinates(points) # action=\"draw\" by default\nplot.plot_options = \"smooth cycle, tension = 0.5\"\n</code></pre> produces the image </p> <p></p> <p>Alternatively we can set <code>action = \"fill\"</code> (analogous to <code>\\fill</code> in Tikz) as in the code below <pre><code>import tikzpy\ntikz = tikzpy.TikzPicture()\npoints = [(2, 2), (4, 0), (1, -3), (-2, -1), (-1, 3)]\nplot = tikz.plot_coordinates(points, options=\"Blue\", action=\"fill\")\nplot.plot_options = \"smooth cycle, tension = 0.5\"\n</code></pre> to produce the image</p> <p></p> <p>If we want both, we can set <code>action = \"filldraw\"</code> (analogous to <code>\\filldraw</code> in Tikz) <pre><code>import tikzpy\ntikz = tikzpy.TikzPicture()\npoints = [(2, 2), (4, 0), (1, -3), (-2, -1), (-1, 3)]\nplot = tikz.plot_coordinates(points, options=\"Blue\", action=\"filldraw\")\nplot.options = \"fill=ProcessBlue!50\"\nplot.plot_options = \"smooth cycle, tension = 0.5\"\n</code></pre> which produces.  </p> <p>Finally, we can set <code>action = \"path\"</code> (analogous to <code>\\path</code> in Tikz), but as one would expect this doesn't draw anything. </p>"},{"location":"Drawing%20Objects/plot_coordinates/#methods","title":"Methods","text":"<p><code>PlotCoordinates</code> has methods <code>.shift()</code>, <code>.scale</code>, and <code>.rotate</code>, similar to the class <code>Line</code>, and the parameters behave similarly. These methods are more interestingly used on <code>PlotCoordinates</code> than on <code>Line</code>. For example, the code <pre><code>import tikzpy\ntikz = tikzpy.TikzPicture()\npoints = [(14.4, 3.2), (16.0, 3.6), (16.8, 4.8), (16.0, 6.8), (16.4, 8.8), (13.6, 8.8), (12.4, 7.6), (12.8, 5.6), (12.4, 3.6)]\nfor i in range(0, 20):\noptions = f\"fill = {rainbow_colors(i)}, opacity = 0.7\"\n# Requires \\usetikzlibrary{hobby} here\nplot_options = \"smooth, tension=.5, closed hobby\"\nplot = tikz.plot_coordinates(points, options, plot_options)\nplot.scale((20 - i) / 20) # Shrink it \nplot.rotate(15 * i) # Rotate it\n</code></pre> generates the image</p> <p></p>"},{"location":"Drawing%20Objects/point/","title":"<code>Point</code>","text":"<p>The <code>Point</code> class is how TikzPy handles coordinates. All drawing objects, like <code>Line</code> and <code>Circle</code>, use the <code>Point</code> class under the hood. However, the class is exposed publicly for convenience of the user since it is useful in scripting.</p> <p>The signature of the class is given below. <pre><code>Point(x, y, z)\n</code></pre></p> Parameter Description Default <code>x</code> (<code>Union[Number, tuple]</code>) A float, corresponding to the x coordinate, or a tuple of floats. <code>y</code> (<code>Optional[Number]</code>) A float, corresponding to the y coordinate. <code>None</code> <code>z</code> (<code>Optional[Number]</code>) A float, corresponding to the z coordinate. <code>None</code> <p>The <code>Point</code> class can be instantiated from a tuple or at least two <code>Number</code>s. One can also represent a point in 3D with this class.</p> <p><pre><code>&gt;&gt;&gt; from tikzpy import Point\n&gt;&gt;&gt; my_point = Point(-1, 2)\n&gt;&gt;&gt; my_point.x\n-1\n&gt;&gt;&gt; my_point.y\n2\n</code></pre> You can also perform arithmetic with <code>Point</code> objects, either with other <code>Point</code> objects or with Python tuples. For example, the following are all valid. <pre><code>&gt;&gt;&gt; my_point + (1, 1)  # Add it to another tuple\nPoint(0, 3)\n&gt;&gt;&gt; my_point + Point(2, 2)  # Add it with another point object\nPoint(1, 4)\n&gt;&gt;&gt; 2 * my_point  # Can also do my_point * 2 \nPoint(-2, 4)\n&gt;&gt;&gt; my_point / 3 \nPoint(-0.33333333, 0.666666666)\n</code></pre></p> <p>This allows you to write things like <pre><code>&gt;&gt;&gt; circle = tikz.circle((0,0), radius=3)\n&gt;&gt;&gt; circle.center += (1, 1)  # This is valid\n&gt;&gt;&gt; circle.center /= 3  # Also valid\n</code></pre> and this feature becomes quite useful in drawings that are highly complex.</p>"},{"location":"Drawing%20Objects/rectangle/","title":"<code>Rectangle</code>","text":"<p>The <code>Rectangle</code> class is used to handle rectangles in TikZ. It is analagous to the TikZ code  <pre><code>\\draw[&lt;options&gt;] &lt;left_corner&gt; rectangle &lt;right_corner&gt;;\n</code></pre> The signature of the class is given below. <pre><code>from tikzpy import Rectangle\nrectangle = Rectangle(left_corner, right_corner, options, action)\n</code></pre></p> Parameter Description Default <code>left_corner</code>  (tuple) A tuple (x, y) of floats representing the position of the node. <code>right_corner</code> (str) String containing valid Tikz node options (e.g., \"above\") <code>\"\"</code> <code>options</code> (str) A string containing valid Tikz draw optins, (e.g, \"fill = Blue\"). <code>\"\"</code> <code>action</code> (str) An action to perform with the rectangle (e.g., <code>\\draw</code>, <code>\\fill</code>, <code>\\filldraw</code>, <code>\\path</code>) <code>\"\\draw\"</code>"},{"location":"Drawing%20Objects/rectangle/#example","title":"Example","text":"<p>Rectangles are often used as a background to many figures; in this case,  we create a fancy colored background.</p> <pre><code>import tikzpy\ntikz = tikzpy.TikzPicture()\ntikz.rectangle((-3.5, -2.5), (4.5, 2.5), options=\"rounded corners, Yellow!30\",action=\"filldraw\")\n# Params\nr = 2\nn_nodes = 7\nnodes = []\n# Draw the nodes\nfor i in range(1, n_nodes + 1):\nangle = 2 * math.pi * i / n_nodes \nx = r * math.cos(angle)\ny = r * math.sin(angle)\nnode = tikz.node((x, y), text=f\"$A_{{{i}}}$\")\nnodes.append(node)\n# Draw the lines between the nodes\nfor i in range(len(nodes)):\nstart = nodes[i].position\nend = nodes[(i + 1) % len(nodes)].position\ntikz.line(start, end, options=\"-&gt;, shorten &gt;= 10pt, shorten &lt;=10pt\")\n</code></pre> <p></p>"},{"location":"Drawing%20Objects/rectangle/#methods","title":"Methods","text":"<p><code>Rectangle</code> has access to methods <code>.shift()</code>, <code>.scale()</code>, <code>.rotate()</code>, which behave as one would expect and takes in parameters as described before.</p>"},{"location":"Drawing%20Objects/scope/","title":"<code>Scope</code>","text":"<p>The <code>Scope</code> class is meant to handle the <code>scope</code> environment in TikZ.  Scoping is useful as it can be used to nest a set of commands in a TikZ picture, or it can be used in conjunction with the TikZ <code>clip</code> command to \"clip out\" drawings. </p> <p>This class is analagous to the TikZ command  <pre><code>\\begin{scope}\n    ...\n\\end{scope}\n</code></pre></p> <p>The signature of the class is given below. <pre><code>from tikzpy import Scope\nscope = Scope(options)\n</code></pre></p> Parameter Description Default <code>options</code> (str) A string of valid Tikz         options. <code>\"\"</code>"},{"location":"Drawing%20Objects/scope/#methods","title":"Methods","text":""},{"location":"Drawing%20Objects/scope/#scopeappenddraw_obj","title":"<code>Scope.append(draw_obj)</code>","text":"<p>Appends any drawing object <code>draw_obj</code> to the scope environment. If one updates an attribute of a drawing object even after it has been appended, the updates are reflected in scope. </p>"},{"location":"Drawing%20Objects/scope/#scoperemovedraw_obj","title":"<code>Scope.remove(draw_obj)</code>","text":"<p>Removes a drawing object <code>draw_obj</code> which has been appended to the scoping environment.</p>"},{"location":"Drawing%20Objects/scope/#scopeclipdraw_obj-draw","title":"<code>Scope.clip(draw_obj, draw)</code>","text":"<p>Clips the drawing object <code>draw_obj</code> from the scope environment by creating an instance of the class <code>Clip</code>. Here, <code>draw</code> is a boolean regarding whether or not you want to actually draw what you are clipping. It is set to <code>False</code> by default. </p> <p>The class <code>Scope</code> also as access to methods <code>.shift()</code>, <code>.scale()</code>, <code>.rotate()</code>. In this case, such operations are applied to every single member of the scoping environment, made possible by the fact that every drawing object itself has access to these methods. These work as one would expect, which is unlike Tikz, since sometimes applying transformations to scoping environments in Tikz does not behave intuitively. </p>"}]}